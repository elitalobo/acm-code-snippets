inline namespace Infinity
{
inline namespace Geometry
{
typedef long double Real;

class Point
{
public:
    Point(Real x = 0, Real y = 0) : x(x), y(y) {}
    Point(const pair<int, int> &p) : x(p.first), y(p.second) {}
    Real x;
            Real y;
};

class Line
{
public:
    Line(Real a, Real b, Real c) : a(a), b(b), c(c) {}
    Line(Point p1, Point p2)
    {
        assert(p1.x != p2.x || p1.y != p2.y);
        a = p2.y - p1.y;
        b = p1.x - p2.x;
        c = p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y);
    }
    Real a, b, c;
};

class Circle
{
public:
    Circle(Point center, Real radius) : center(center), radius(radius) {}
    Point center;
    Real radius;
};

const Real pi = acosl(-1);
// use eps when comparing Reals
const Real eps = 1e-15l;

Real sq(Real a)
{
    return a * a;
}

Real dist(Point a, Point b)
{
    return sqrtl(sq(a.x - b.x) + sq(a.y - b.y));
}

bool parallel(Line l1, Line l2)
{
    return l1.a * l2.b - l1.b * l2.a == 0;
}

Point intersection(Line l1, Line l2)
{
    assert(parallel(l1, l2) == false);
    return Point((l1.b * l2.c - l2.b * l1.c) / (l1.a * l2.b - l2.a * l1.b),
                 (l1.a * l2.c - l2.a * l1.c) / (l2.a * l1.b - l1.a * l2.b));
}

Point footPoint(Point pt, Line ln)
{
    Line pl(ln.b, -ln.a, pt.y * ln.a - pt.x * ln.b);
    return intersection(ln, pl);
}

Real dist(Point pt, Line ln)
{
    return fabsl(ln.a * pt.x + ln.b * pt.y + ln.c) / sqrtl(sq(ln.a) + sq(ln.b));
}

Real arcArea(Real ang, Real r)
{
    return (ang - sinl(ang)) * r * r / 2;
}

Real circlesJointArea(Real x1, Real y1, Real r1, Real x2, Real y2, Real r2)
{
    if (r1 < r2) { swap(x1, x2); swap(y1, y2); swap(r1, r2); }
    Real d = dist(x1, y1, x2, y2);
    if (d + r2 <= r1) return r2 * r2 * pi;
    if (d >= r1 + r2) return 0;
    Real ang1 = acosl((d * d + r1 * r1 - r2 * r2) / (2 * d * r1));
    Real ang2 = acosl((d * d + r2 * r2 - r1 * r1) / (2 * d * r2));
    return arcArea(ang1 * 2, r1) + arcArea(ang2 * 2, r2);
}

} // namespace Geometry
} // namespace Infinity
