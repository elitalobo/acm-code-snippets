Binary Indexed Tree

#include <vector>

class BinaryIndexedTree
{
public:
    BinaryIndexedTree(const int &n) { a.resize(n + 1, 0); }
    BinaryIndexedTree(int *begin, int *end) : a(begin, end) {}
    static int lowbit(const int x) { return -x & x; }
    int sum(int n) const { int s = 0; while (n > 0) { s += a[n]; n -= lowbit(n); } return s; }
    int sum(int l, int r) const { return sum(r) - sum(l - 1); }
    void add(unsigned int pos, const int k) { while (pos < a.size()) { a[pos] += k; pos += lowbit(pos); } }
protected:
    vector<int> a;
};

template<typename T>
class vector2d
{
public:
    vector2d(uint x, uint y, T value = T()) : a(x, vector<T>(y, value)) {}
    vector<vector<T> > data() { return a; }
    vector<T> &operator [](uint x) { return a[x]; }
    uint size() const { return a.size(); }
    void resize(uint n, T x = T()) { a.resize(n, x); }
protected:
    vector<vector<T> > a;
};

class BinaryIndexedTree2D
{
public:
    BinaryIndexedTree2D(uint n, uint m) : a(n + 1, m + 1) {}
    static int lowbit(const int x) { return -x & x; }
    void add(uint x, uint y, int k) { for (uint i = x; i < a.size(); i += lowbit(i)) for (uint j = y; j < a[i].size(); j += lowbit(j)) a[i][j] += k; }
    int sum(uint x, uint y) { int s = 0; for (int i = x; i > 0; i -= lowbit(i)) for(int j = y; j > 0; j -= lowbit(j)) s += a[i][j]; return s; }
    int sum(uint x1, uint y1, uint x2, uint y2) { return sum(x2, y2) - sum(x1 - 1, y1 - 1); }
protected:
    vector2d<int> a;
};

Binary Tree and Recovering

template<typename DataType>
class BinaryTreeNode
{
public:
    BinaryTreeNode(DataType data) :
        left(NULL), right(NULL), data(data) {}
    BinaryTreeNode *left;
    BinaryTreeNode *right;
    DataType data;
};

typedef BinaryTreeNode<char> TreeNode;
TreeNode *make_tree(const char *preorder, const char *inorder, int length)
{
    if (length == 0) return NULL;
    int root = 0;
    while (root < length && inorder[root] != preorder[0]) root++;
    TreeNode *node = new TreeNode(preorder[0]);
    node->left = make_tree(preorder + 1, inorder, root);
    node->right = make_tree(preorder + root + 1, inorder + root + 1, length - root - 1);
    return node;
}

template<typename DataType>
void print_postordered_tree(BinaryTreeNode<DataType> *node, ostream &os = cout)
{
    if (node == NULL) return;
    print_postordered_tree(node->left, os);
    print_postordered_tree(node->right, os);
    os << node->data;
}

Combination & Stirling II

const int mod = 1000000007;

class Combination
{
public:
    Combination(int n, int m = mod) : n(n), m(m), a(new int *[n + 1])
    {
        for (int i = 0; i <= n; i++) a[i] = new int[n + 1];
        for (int i = 0; i <= n; i++) { a[0][i] = 0; a[i][0] = 1; }
        for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) a[i][j] = (a[i - 1][j] + a[i - 1][j - 1]) % m;
    }
    int c(int n, int m) { return a[n][m]; }
protected:
    int n;
    int m;
    int **a;
};

class StirlingII
{
    typedef long long ll;
public:
    StirlingII(int n, int m = mod) : n(n), m(m), a(new int *[n + 1])
    {
        for (int i = 0; i <= n; i++) a[i] = new int[n + 1];
        for (int i = 0; i <= n; i++) for (int j = 0; j <= n; j++) a[i][j] = 0;
        for (int i = 0; i <= n; i++) a[i][1] = a[i][i] = 1;
    }
    int s(int i, int j)
    {
        if (i < j) return 0;
        if (!i || !j) return 0;
        if (a[i][j]) return a[i][j];
        a[i][j] = (s(i - 1, j - 1) + ll(j) * s(i - 1, j)) % m;
        return a[i][j];
    }
protected:
    int n;
    int m;
    int **a;
};

Coordinate Transformation 45

template<typename T>
class CoordinateTransformation45
{
    typedef pair<T, T> ptt;
public:
    CoordinateTransformation45(int maxn) : n(maxn) {}
    ptt convert(const ptt &p) { return ptt(p.first + p.second, p.second - p.first + n); }
    ptt convert(const T x, const T y) { return convert(ptt(x, y)); }
protected:
    int n;
};

Discretization

template<typename T>
class Discretization
{
public:
    Discretization(vector<T> &v) : data(v) { sort(data.begin(), data.end()); data.erase(unique(data.begin(), data.end()), data.end()); }
    Discretization(T *l, T *r) : data(l, r) { sort(data.begin(), data.end()); data.erase(unique(data.begin(), data.end()), data.end()); }
    T &operator [](const int n) const { return data[n]; }
    int size() const { return data.size(); }
    int indexOf(const T &t) const { return lower_bound(data.begin(), data.end(), t) - data.begin(); }
protected:
    vector<T> data;
};

Eular Phi and prime factor

// get prime factor of n and phi[n]
class Euler
{
public:
    static vector<pii> fact(int n) // O(sqrt(n))
    {
        vector<pii> fact;
        for (int i = 0; prime[i]*prime[i] <= n; i++)
        {
            pii p(prime[i], 0);
            while (n % prime[i] == 0)
            {
                n /= prime[i];
                p.second++;
            }
            if (p.second != 0)
                fact.push_back(p);
        }
        if (n > 1)
            fact.push_back(pii(n, 1));
        return fact;
    }
    static string show_fact(int n, string split = " ")
    {
        stringstream ss;
        vector<pii> fct = fact(n);
        for (vector<pii>::iterator j = fct.begin(); j != fct.end(); j++)
            for (int k = 0; k < j->second; k++)
                ss << j->first << split;
        string s = ss.str();
        s.erase(s.end()-split.length(), s.end());
        return s;
    }
    static long long phi(int n)
    {
        long long phi = 1;
        vector<pii> fct = fact(n);
        FORITER(i, fct)
            phi *= (i->first-1) * pow(i->first, i->second-1); 
            // can also use qpow accelerator
        return phi;
    }
};


// make a list of phi[i]
class EulerPhi
{
public:
    EulerPhi(int n) : arr(new int[n+1]) // O(nlglgn)
    {
        clr(arr);
        for (int i = 2 ; i <= n ; i ++ )
            if (!arr[i])
                for (int j = i; j <= n; j += i)
                {
                    if (!arr[j])
                        arr[j] = j ;
                    arr[j] = arr[j]/i*(i-1);
                }
    }
    int operator [](int n) { return arr[n]; }
protected:
    int *arr;
};

Find parent

class TreeNode
{
public:
    void connect(TreeNode *tn) { this->sons.push_back(tn); tn->sons.push_back(this); }
    void find_parent(TreeNode *setParent = NULL) 
    { 
        if (setParent != NULL) 
        { 
            parent = setParent; 
            FORITER(i, sons) 
                if (*i == parent) 
                { 
                    sons.erase(i); 
                    break; 
                } 
        } 
        FORITER(i, sons) 
            (*i)->find_parent(this); 
    }
    void clear_parent() { FORITER(i, sons) (*i)->clear_parent(); sons.push_back(parent); parent = NULL; }
    TreeNode *parent;
    list<TreeNode *> sons;
};


Joseph (recursive)

class Joseph // recursive
{
public:
    Joseph(int n, int k) : n(n), k(k) {} // n people exit every k
    idx(int i) { return ext(n, k, i); } // index of the i-th person
private:
    int ext(int n, int k, int i) { return (i == 1 ? (n + k - 1) % n : (ext(n - 1, k, i - 1) + k) % n); }
protected:
    int n;
    int k;
};

Knuth-Morris-Pratt

class Knuth_Morris_Pratt
{
public:
    static int kmpc(const string &s, const string &t)
    {
        vector<int> next = getNext(t);
        int n = s.size();
        int m = t.size();
        int count = 0;
        for (int index = 0; index < n; index++)
        {
            int pos = 0;
            int itr = index;
            while (pos < m && itr < n)
            {
                if(s[itr] == t[pos])
                {
                    itr++;
                    pos++;
                }
                else
                {
                    if(pos == 0)
                        itr++;
                    else
                        pos = next[pos - 1] + 1;
                }
            }
            if (pos == m && (itr - index) == m)
                count++;
        }
        return count;
    }
private:
    static vector<int> getNext(const string &str)
    {
        int n = str.size();
        vector<int> next(n);
        next[0] = -1;
        for(int i = 1; i < n; i++)
        {
            int j = next[i - 1];
            while (str[i] != str[j + 1] && j >= 0)
                j = next[j];
            if (str[i] == str[j + 1])
                next[i] = j + 1;
            else
                next[i] = 0;
        }
        return next;
    }
};

Mapper

template<typename T>
class Mapper
{
public:
    Mapper() : m(), n(0) {}
    void clear() { m.clear(); }
    int operator [](const T idx) { if (m.count(idx) == 0) m[idx] = ++n; return m[idx]; }
protected:
    map<T, int> m;
    int n;
};

Miller-Robin and Rho

class MathFoward
{
protected:
    static ll mul(ll a, ll b, ll p)
    {
        ll rn = 0, i;
        for(i = 1; i <= b; i <<= 1, a = (a + a) % p)
            if(b & i) rn = (rn + a) % p;
        return rn;
    }
    static ll ksm(ll a, ll b, ll p)
    {
        ll rn = 1;
        for(; b; a = mul(a, a, p), b >>= 1)
            if(b & 1) rn = mul(rn, a, p);
        return rn;
    }
};

class Miller_Robin : public MathFoward
{
public:
    static bool isPrime(ll n)
    {
        if (n == 2)
            return true;
        if (n < 2 || !(n & 1))
            return false;
        ll a, x, y, u = n - 1;
        int t = 0;
        while ((u & 1) == 0)
            t++, u >>= 1;
        for (int i = 0; i < 5; i++)
        {
            a = tester[i];
            if (n <= a)
                continue;
            x = ksm(a, u, n);
            for (int j = 1; j <= t; j++)
            {
                y = mul(x, x, n);
                if (y == 1 && x != 1 && x != n - 1)
                    return false;
                x = y;
            }
            if (x != 1) return false;
        }
        return true;
    }
private:
    static const int tester[5];
};
const int Miller_Robin::tester[] = {2, 3, 5, 7, 641};

class Rho : private Miller_Robin
{
public:
    static vector<int> fact(ll n)
    {
        list.clear();
        rho(n);
        srt(list);
        return list;
    }
private:
    static void rho(ll n)
    {
        if (isPrime(n))
        {
            list.push_back(n);
            return;
        }
        for(; ; )
        {
            int p = 1;
            for (ll x = 1, y = 1, z = rand() + 1; p == 1; )
            {
                y = (mul(y, y, n) + z) % n;
                p = gcd((x - y + n) % n, n);
                x = (mul(x, x, n) + z) % n;
                y = (mul(y, y, n) + z) % n;
            }
            if (p == n) continue;
            rho(p), rho(n / p);
        }
    }
    static vector<int> list;
};
vector<int> Rho::list;

ModLongLong

template<unsigned long long n>
class ModLongLong
{
    typedef long long ll;
    typedef ModLongLong mll;
    static void exGcd(ll a, ll b, ll &x, ll &y) { if (b) { exGcd(b, a % b, y, x);  y -= a / b * x; } else { x = 1; y = 0; } }
public:
    ModLongLong(const ll &a) : data((a + n) % n) {}
    ll toLongLong() const { return data; }
    mll friend operator +(const mll &a, const mll &b) { return ModLongLong((a.data + b.data) % n); }
    mll friend operator -(const mll &a, const mll &b) { return ModLongLong((a.data - b.data + n) % n); }
    mll friend operator *(const mll &a, const mll &b) { return ModLongLong((a.data * b.data) % n); }
    mll friend operator /(const mll &a, const mll &b) { ll x = 0, y = 0; exGcd(b.data, n, x, y); x = (x + n) % n; return ModLongLong((a.data * x) % n); }
    mll operator +=(const mll &b) { *this = *this + b; return *this; }
    mll operator -=(const mll &b) { *this = *this - b; return *this; }
    mll operator *=(const mll &b) { *this = *this * b; return *this; }
    mll operator /=(const mll &b) { *this = *this / b; return *this; }
protected:
    ll data;
};

const ll mod = 1000000007ll;

typedef ModLongLong<mod> mll;

Quick Power

ll qpow(ll a, ll b, ll c) // a^b % c (a, b, c < INT_MAX)
{
    ll p = 1;
    while (b)
    {
        if (b & 1)
            p = (p * a) % c;
        a = (a * a) % c;
        b >>= 1;
    }
    return p;
}

Segment Tree (Object Oriented)

// object oriented
// be careful of memory usage

class SegmentTreeNode
{
public:
    SegmentTreeNode(int l, int r, int min = maxint, int max = -maxint) :
        left(NULL), right(NULL), minimum(min), maximum(max), interval_l(l), interval_r(r) {}
    int minimum_of(int begin, int end)
    {
        if (begin <= interval_l && interval_r <= end) return minimum;
        if (interval_r < begin || end < interval_l) return maxint;
        return min(this->left->minimum_of(begin, end), this->right->minimum_of(begin, end));
    }
    int maximum_of(int begin, int end)
    {
        if (begin <= interval_l && interval_r <= end) return maximum;
        if (interval_r < begin || end < interval_l) return -maxint;
        return max(this->left->maximum_of(begin, end), this->right->maximum_of(begin, end));
    }
    static SegmentTreeNode *make_tree(int a[], int begin, int end)
    {
        if (begin == end) return new SegmentTreeNode(begin, end, a[begin], a[end]);
        SegmentTreeNode *node = new SegmentTreeNode(begin, end);
        node->left = make_tree(a, begin, (begin + end) / 2);
        node->right = make_tree(a, (begin + end) / 2 + 1, end);
        node->minimum = min(node->left->minimum, node->right->minimum);
        node->maximum = max(node->left->maximum, node->right->maximum);
        return node;
    }
protected:
    SegmentTreeNode *left;
    SegmentTreeNode *right;
    int minimum;
    int maximum;
    int interval_l;
    int interval_r;
private:
    static const int maxint = 2147483647;
};

Segment Tree

class SegmentTree
{
public:
    SegmentTree(const int n) : n(n), minimum(new int[4 * n]), maximum(new int[4 * n]) {}
    inline int size() { return n; }
    void make_tree(const int a[], const int i = 1, const int l = 0, int r = -1)
    {
        if (r == -1) r += n;
        if (l == r) { minimum[i] = a[l]; maximum[i] = a[r]; return; }
        make_tree(a, left(i), l, (l + r) / 2);
        make_tree(a, right(i), (l + r) / 2 + 1, r);
        minimum[i] = std::min(minimum[left(i)], minimum[right(i)]);
        maximum[i] = std::max(maximum[left(i)], maximum[right(i)]);
    }
    int min(const int begin, const int end, const int i = 1, const int l = 0, int r = -1) const
    {
        if (r == -1) r += n;
        if (begin <= l && r <= end) return minimum[i];
        if (r < begin || end < l) return maxint;
        return std::min(min(begin, end, left(i), l, (l + r) / 2), min(begin, end, right(i), (l + r) / 2 + 1, r));
    }
    int max(const int begin, const int end, const int i = 1, const int l = 0, int r = -1) const
    {
        if (r == -1) r += n;
        if (begin <= l && r <= end) return maximum[i];
        if (r < begin || end < l) return -maxint;
        return std::max(max(begin, end, left(i), l, (l + r) / 2), max(begin, end, right(i), (l + r) / 2 + 1, r));
    }
    void add(const int pos, const int inc, const int i = 1, const int l = 0, int r = -1)
    {
        if (r == -1) r += n;
        if (l == r) { minimum[i] += inc; maximum[i] += inc; return; }
        if (pos < l || r < pos) return;
        add(pos, inc, left(i), l, (l + r) / 2);
        add(pos, inc, right(i), (l + r) / 2 + 1, r);
        minimum[i] = std::min(minimum[left(i)], minimum[right(i)]);
        maximum[i] = std::max(maximum[left(i)], maximum[right(i)]);
    } // not tested
private:
    static const int maxint = 2147483647;
    static int left(int i) { return 2 * i; }
    static int right(int i) { return 2 * i + 1; }
protected:
    const int n;
    int *minimum;
    int *maximum;
};


Union (countable)

struct Union
{
public:
    Union(int n) { for (int i = 0; i <= n; i++) anc.push_back(i), cnt.push_back(1); }
    int find(int x) { /* be careful of stack overflow */ if (anc[x] == x) return x; anc[x] = find(anc[x]); return anc[x]; }
    void connect(int x, int y) { int t = count(x); anc[find(x)] = find(y); cnt[find(y)] += t; }
    bool isConnected(int x, int y) { return find(x) == find(y); }
    int count(int x) { return cnt[find(x)]; }
protected:
    vector<int> anc;
    vector<int> cnt;
};

Union (non-recursive)

struct Union
{
public:
    Union(int n) { for (int i = 0; i <= n; i++) ancestor.push_back(i); }
    int find(int n) 
    { 
        int anc = n; 
        while (ancestor[anc] != anc) anc = ancestor[anc]; 
        while (ancestor[n] != n) { n = ancestor[n]; ancestor[n] = anc; } 
        return anc; 
    }
    void connect(int x, int y) { ancestor[find(y)] = find(x); }
    bool isConnected(int x, int y) { return find(x) == find(y); }
protected:
    vector<int> ancestor;
};

vector2d3d

#include <vector>

template<typename T>
class vector2d
{
public:
    vector2d(int x, int y, T value = T()) : mydata(x, vector<T>(y, value)) {}
    vector<vector<T> > data() { return mydata; }
    vector<T> &operator [](int x) { return mydata[x]; }
    int size() const { return mydata.size(); }
protected:
    vector<vector<T> > mydata;
};

template<typename T>
class vector3d
{
public:
    vector3d(int x, int y, int z, T value = T()) : mydata(x, vector2d<T>(y, z, value)) {}
    vector<vector2d<T> > data() { return mydata; }
    vector2d<T> &operator [](int x) { return mydata[x]; }
    int size() const { return mydata.size(); }
protected:
    vector<vector2d<T> > mydata;
};

_headfile

// includes
#include <algorithm>
#include <cctype>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <functional>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <list>
#include <map>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <utility>
#include <vector>

// macro of control statement
#define FOR(i, n) for (int i = 0; i < n; i++)
#define FOR1(i, n) for (int i = 1; i <= n; i++)
#define FORITER(i, a) for (__typeof a.begin() i = a.begin(); i != a.end(); i++)

#define DEBUG(a) cout << "Line " << __LINE__  << ": " #a " = " << (a) << endl

// namespace
using namespace std;

// type definitions
typedef unsigned int uint;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> pii;

// constants
const int maxint = 2147483647;

// simplifying functions
inline int ctoi(const char c) { return c - '0'; }
inline char itoc(const int n) { return n + '0'; }
template<typename T> inline bool in(T x, T l, T r) { return l <= x && x <= r; }

// stl functions
template<typename T1, typename T2> inline pair<T1, T2> mp(const T1 &fst, const T2 &scd) { return make_pair(fst, scd); }
template<class T> inline void srt(T &a) { sort(a.begin(), a.end()); }
template<class T> inline void srt(vector<T> &a, bool(&comp)(const T &, const T &)) { sort(a.begin(), a.end(), comp); }
template<class T1, typename T2> inline int lbs(const T1 &a, const T2 k) { return lower_bound(a.begin(), a.end(), k); }
template<class T1, typename T2> inline int ubs(const T1 &a, const T2 k) { return upper_bound(a.begin(), a.end(), k); }

// anti stack overflow
void expandStack(int size = 67108864) // 64 megabytes
{
#ifdef __GNUC__
    char *p = (char*) malloc(size) + size;
#   ifdef __i386__
    __asm__("movl %0, %%esp\n" :: "r"(p));
#   else
    __asm__("movq %0, %%rsp\n" :: "r"(p));
#   endif
#else
#pragma comment(linker, "/STACK:1024000000,1024000000") // < 1G
#endif
}

// infinity's IO functions
namespace InfinitysIO
{
const char SP = ' ';
const char CR = '\n';
inline void write(const int n) { printf("%d", n); }
inline void write(const uint n) { printf("%u", n); }
inline void write(const ll n) { cout << n; }
inline void write(const double a) { printf("%f", a); }
inline void writef(const double a, const int n) { printf("%.*f", n, a); }
inline void write(const char c) { printf("%c", c); }
inline void write(const char s[] = "") { printf("%s", s); }
inline void write(const string s) { cout << s; }
inline void writes(const int *a, const int l, const int r) { for (int i = l; i <= r; i++) printf("%d ", a[i]); }
template<uint n> inline void write(const int (&a)[n]) { for (uint i = 0; i < n; i++) printf("%d ", a[i]); }
template<class T> inline void write(const T a) { for (__typeof a.begin() i = a.begin(); i != a.end(); i++) printf("%d ", *i); }
inline void writeln() { write(CR); }
template<typename T> inline void writeln(const T &a) { write(a); write(CR); }
inline void writefln(const double a, int n) { printf("%.*f", n, a); write(CR); }
inline void writesln(const int *a, const int l, const int r) { for (int i = l; i <= r; i++) printf("%d ", a[i]); writeln(CR); }
template<class T> inline void writelns(const T a) { for (__typeof a.begin() i = a.begin(); i != a.end(); i++) writeln(*i); }
#if __cplusplus >= 201103L
template<typename T, typename... types> inline void write(const T &a, const types &...args) { write(a); write(args...); }
template<typename... types> inline void writeln(const types &...args) { write(args...); write(CR); }
#endif
inline int read(int &n) { return scanf("%d", &n); }
#ifndef ONLINE_JUDGE
inline int read(ll &n) { return scanf("%lld", &n); }
#else
inline int read(ll &n) { return scanf("%I64d", &n); }
#endif
// ignoring EOF
inline int getint() { int n; read(n); return n; }
inline ll getll() { ll n; read(n); return n; }
// array and STL container
template<uint n> inline void reads(int (&a)[n]) { for (uint i = 0; i < n; i++) a[i] = getint(); }
inline void reads(int *a, int l, int r) { for (int i = l; i <= r; i++) a[i] = getint(); }
inline void reads(vector<int> &v, int n) { v.clear(); for (int i = 0; i < n; i++) v.push_back(getint()); }
// std::string
#ifdef __GNUC__
inline void read(string &str, uint size) { char s[size]; scanf("%s", s); str = string(s); }
#else
inline void read(string &str, uint) { cin >> str; }
#endif
inline string getstr(uint size = 1024) { string s; read(s, size); return s; }
} using namespace InfinitysIO;

// cstring
template<typename T> inline void clr(T &a) { memset(a, 0, sizeof a); }
// math
template<typename T> T gcd(T a, T b) { return (b ? gcd(b, a % b) : a); }
template<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }
// find (x, y) s.t. a x + b y = gcd(a, b) = d
template<typename T> T exGcd(T a, T b, T &x, T &y)
{ T d = a; if (b) { d = exGcd(b, a % b, y, x); y -= a / b * x; } else { x = 1; y = 0; } return d; }

// end

